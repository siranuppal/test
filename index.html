<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KOLPITO | Spatial Computing OS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Camera Feed Background */
        #camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            /* Flip horizontally if using front camera, but we want rear usually */
        }

        /* The WebGL Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay for Boot/Permissions */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            color: white;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-weight: 200;
            letter-spacing: 4px;
            margin-bottom: 10px;
            font-size: 2rem;
            background: linear-gradient(90deg, #fff, #a0c4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p.status {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 30px;
        }

        button.start-btn {
            padding: 15px 40px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button.start-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
        }

        /* Center line for VR calibration */
        .vr-divider {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 5;
            display: none;
            pointer-events: none;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- Video Element for AR Pass-Through -->
    <video id="camera-feed" autoplay playsinline muted></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- VR Split Divider -->
    <div class="vr-divider" id="vr-divider"></div>

    <!-- Initial Boot Screen -->
    <div id="ui-layer">
        <h1>KOLPITO OS</h1>
        <p class="status" id="status-text">Ready to Initialize Spatial Environment</p>
        <button class="start-btn" id="start-btn">Boot System</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            fov: 75,
            ipd: 0.6, // Interpupillary distance approx
            reticleColor: 0xffffff,
            hoverColor: 0x64b5f6,
            iconSize: 1.2,
            dockRadius: 8,
            dockY: -2
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let appsGroup = new THREE.Group();
        let windowsGroup = new THREE.Group();
        let reticleLeft, reticleRight; // One for each eye
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(0, 0); // Always center for gaze
        
        let icons = []; // Array to store icon meshes for raycasting
        let isRunning = false;
        
        // Gyroscope State
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let screenOrientation = 0;

        // --- ASSET GENERATION (Procedural Textures) ---
        
        function createTextTexture(text, subtext, color) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Glass background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.roundRect(20, 20, size - 40, size - 40, 60);
            ctx.fill();

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 10;
            ctx.stroke();

            // Icon/Symbol
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 200px Arial';
            ctx.fillText(text.substring(0, 1), size / 2, size / 2 - 20);

            // Label
            ctx.font = '30px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText(subtext, size / 2, size - 80);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createWindowContent(title) {
            const width = 1024;
            const height = 768;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Window Chrome
            ctx.fillStyle = 'rgba(20, 20, 30, 0.85)';
            ctx.beginPath();
            ctx.roundRect(0, 0, width, height, 40);
            ctx.fill();

            // Header
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, width, 80);

            // Title
            ctx.font = 'bold 40px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.fillText(title, 40, 55);

            // Dummy Content
            ctx.font = '30px sans-serif';
            ctx.fillStyle = '#aaa';
            ctx.fillText("Spatial Application Loaded.", 40, 150);
            ctx.fillText("Gaze at content to interact.", 40, 200);

            // Abstract graphics
            ctx.fillStyle = '#334';
            ctx.fillRect(40, 250, 400, 300);
            ctx.fillStyle = '#343';
            ctx.fillRect(460, 250, 400, 300);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- THREE.JS SETUP ---

        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // No background color, transparent so video shows through
            
            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 100);
            // Initial camera pos
            camera.position.set(0, 0, 0.1);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; // Important for stereo split
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 10, 5);
            scene.add(dirLight);

            // Build UI
            buildDock();
            buildReticles();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('touchstart', onTouchStart, false); 
            // Also support mouse click for desktop debugging
            document.addEventListener('click', onTouchStart, false);
        }

        function buildDock() {
            scene.add(appsGroup);

            const appList = [
                { name: "S", label: "Settings", color: "#A0C4FF" },
                { name: "B", label: "Browser", color: "#BDB2FF" },
                { name: "P", label: "Photos", color: "#FFC6FF" },
                { name: "M", label: "Mail", color: "#FFFFFC" },
                { name: "F", label: "Files", color: "#CAFFBF" }
            ];

            const radius = CONFIG.dockRadius;
            const totalArc = Math.PI / 3; // 60 degrees spread
            const angleStep = totalArc / (appList.length - 1);
            const startAngle = -totalArc / 2;

            appList.forEach((app, i) => {
                const geometry = new THREE.PlaneGeometry(CONFIG.iconSize, CONFIG.iconSize);
                const texture = createTextTexture(app.name, app.label, app.color);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const icon = new THREE.Mesh(geometry, material);
                
                // Position on a curve
                const angle = startAngle + (i * angleStep);
                icon.position.x = radius * Math.sin(angle);
                icon.position.z = -radius * Math.cos(angle);
                icon.position.y = CONFIG.dockY;
                
                // Look at center
                icon.lookAt(0, CONFIG.dockY, 0);

                // Add data for interaction
                icon.userData = { 
                    isIcon: true, 
                    label: app.label,
                    originalScale: 1
                };

                appsGroup.add(icon);
                icons.push(icon);
            });
            
            scene.add(windowsGroup);
        }

        function buildReticles() {
            // We need a reticle locked to the camera's forward vector.
            // Since we render stereo by shifting the camera, we can put the reticle 
            // in the scene at a fixed distance, or HUD style.
            // For true stereo depth, it's best to place a 3D object at the focal distance.
            
            const geometry = new THREE.RingGeometry(0.02, 0.03, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.reticleColor,
                transparent: true,
                opacity: 0.8,
                depthTest: false // Always on top
            });

            // Create a reticle object that sits inside the camera hierarchy?
            // No, in VR, reticle is usually a cursor in the world.
            // Let's create one reticle in the scene that follows gaze orientation.
            
            // Actually, for this simple implementation, let's child it to the camera group wrapper
            // But we don't have a camera wrapper yet. Let's do it in the render loop.
            // We'll create a mesh and update its position every frame.
            
            reticleLeft = new THREE.Mesh(geometry, material.clone());
            reticleRight = new THREE.Mesh(geometry, material.clone());
            
            // We'll manually render these on top or position them.
            // Easiest: Child to camera.
            camera.add(reticleLeft);
            reticleLeft.position.set(0, 0, -2); // 2 meters in front
            
            // Note: In stereo rendering, childing to camera works, but might look flat.
            // For a robust implementation, we add camera to scene.
            scene.add(camera);
        }

        // --- INTERACTION LOGIC ---

        function openWindow(title) {
            // Close existing windows
            while(windowsGroup.children.length > 0){ 
                windowsGroup.remove(windowsGroup.children[0]); 
            }

            const geometry = new THREE.PlaneGeometry(4, 3);
            const texture = createWindowContent(title);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide 
            });
            
            const win = new THREE.Mesh(geometry, material);
            
            // Place window in front of user relative to current gaze
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            
            // Position it 4 units away
            win.position.copy(camera.position).add(forward.multiplyScalar(4));
            
            // Make it face the camera
            win.lookAt(camera.position);
            
            windowsGroup.add(win);
        }

        function onTouchStart() {
            if (!isRunning) return;

            // Trigger raycast interaction
            // Since reticle is always center screen
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(icons);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                if (hit.userData.isIcon) {
                    // Animate click
                    hit.scale.set(1.1, 1.1, 1.1);
                    setTimeout(() => hit.scale.set(1, 1, 1), 150);
                    openWindow(hit.userData.label);
                }
            } else {
                // If clicked empty space, close windows
                // windowsGroup.clear(); // Not supported in older Three.js
                while(windowsGroup.children.length > 0){ 
                    windowsGroup.remove(windowsGroup.children[0]); 
                }
            }
        }

        // --- CORE LOOP ---

        function updateOrientation() {
            if (!deviceOrientation) return;

            // Convert device orientation to quaternion
            // This is a simplified math version. For production, use THREE.DeviceOrientationControls
            // But we want single file, so we map manually or use a simple approx.
            
            const alpha = deviceOrientation.alpha ? THREE.Math.degToRad(deviceOrientation.alpha) : 0; // Z
            const beta = deviceOrientation.beta ? THREE.Math.degToRad(deviceOrientation.beta) : 0; // X
            const gamma = deviceOrientation.gamma ? THREE.Math.degToRad(deviceOrientation.gamma) : 0; // Y
            const orient = screenOrientation ? THREE.Math.degToRad(screenOrientation) : 0;

            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const q = new THREE.Quaternion();
            q.setFromEuler(euler);
            
            // Fix for screen orientation (landscape)
            const q_rot = new THREE.Quaternion();
            q_rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -orient);
            
            // Adjustment for initial look
            const q_fix = new THREE.Quaternion();
            q_fix.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), -Math.PI / 2 );

            // Combine (Order matters)
            camera.quaternion.copy(q);
            camera.quaternion.multiply(q_fix); // Rotate up to look at horizon
            camera.quaternion.multiply(q_rot); // Fix landscape
        }

        function render() {
            requestAnimationFrame(render);

            updateOrientation();

            // Raycast for Hover Effects
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(icons);
            
            // Reset all scales
            icons.forEach(icon => {
                icon.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
            });

            // Apply hover
            if (intersects.length > 0) {
                const hit = intersects[0].object;
                hit.scale.lerp(new THREE.Vector3(1.3, 1.3, 1.3), 0.2);
            }

            // STEREOSCOPIC RENDER
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setScissorTest(true);

            // 1. LEFT EYE
            renderer.setScissor(0, 0, width / 2, height);
            renderer.setViewport(0, 0, width / 2, height);
            
            // Shift camera left
            camera.position.x = -CONFIG.ipd / 2;
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            // 2. RIGHT EYE
            renderer.setScissor(width / 2, 0, width / 2, height);
            renderer.setViewport(width / 2, 0, width / 2, height);
            
            // Shift camera right
            camera.position.x = CONFIG.ipd / 2;
            camera.updateMatrixWorld();
            renderer.render(scene, camera);
            
            // Reset camera pos for logic calculations next frame
            camera.position.x = 0;
            
            renderer.setScissorTest(false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- BOOT SEQUENCE ---

        const btn = document.getElementById('start-btn');
        const status = document.getElementById('status-text');
        const ui = document.getElementById('ui-layer');
        const video = document.getElementById('camera-feed');
        const divider = document.getElementById('vr-divider');

        btn.addEventListener('click', async () => {
            status.innerText = "Initializing Sensors & Camera...";

            // 1. Request Camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = stream;
            } catch (e) {
                console.warn("Camera failed: " + e);
                status.innerText = "Camera Access Denied (AR Disabled)";
            }

            // 2. Request Device Orientation (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        startSystem();
                    } else {
                        status.innerText = "Gyroscope Denied.";
                        return;
                    }
                } catch (e) {
                    status.innerText = "Sensor Error: " + e;
                    return;
                }
            } else {
                // Non-iOS 13+ devices
                startSystem();
            }
        });

        function startSystem() {
            // Hide UI
            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 500);
            
            // Show Split Divider
            divider.style.display = 'block';

            // Start Orientation Listener
            window.addEventListener('deviceorientation', (e) => {
                deviceOrientation = e;
            });
            window.addEventListener('orientationchange', () => {
                screenOrientation = window.orientation || 0;
            });

            // Init 3D
            init3D();
            isRunning = true;
            render();

            // Force fullscreen
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        }

    </script>
</body>
</html>
