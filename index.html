<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KOLPITO | Spatial Computing OS v2.0</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Camera Feed Background */
        #camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }

        /* The WebGL Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay for Boot/Permissions */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            color: white;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-weight: 200;
            letter-spacing: 4px;
            margin-bottom: 10px;
            font-size: 2rem;
            background: linear-gradient(90deg, #fff, #a0c4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p.status {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 30px;
        }

        button.start-btn {
            padding: 15px 40px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button.start-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
        }

        /* Center line for VR calibration */
        .vr-divider {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 5;
            display: none;
            pointer-events: none;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- Video Element for AR Pass-Through -->
    <video id="camera-feed" autoplay playsinline muted></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- VR Split Divider -->
    <div class="vr-divider" id="vr-divider"></div>

    <!-- Initial Boot Screen -->
    <div id="ui-layer">
        <h1>KOLPITO v2.0</h1>
        <p class="status" id="status-text">System Upgrade Ready. Initialize Sensors.</p>
        <button class="start-btn" id="start-btn">Boot System</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            fov: 75,
            ipd: 0.6, // Interpupillary distance approx
            reticleColor: 0xffffff,
            hoverColor: 0x64b5f6,
            iconSize: 1.2,
            dockRadius: 8,
            dockY: -2.5
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let appsGroup = new THREE.Group();
        let windowsGroup = new THREE.Group();
        let envGroup = new THREE.Group(); // For spatial grid
        let statusBarGroup = new THREE.Group();
        
        let reticleLeft, reticleRight; 
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(0, 0);
        
        let icons = []; 
        let isRunning = false;
        let clock = new THREE.Clock();
        
        // Gyroscope State
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let screenOrientation = 0;

        // --- ASSET GENERATION (Procedural Textures) ---
        
        function createTextTexture(text, subtext, color) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Glass background
            const grad = ctx.createLinearGradient(0, 0, size, size);
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(20, 20, size - 40, size - 40, 80);
            ctx.fill();

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Icon/Symbol
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 40;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 220px Arial';
            ctx.fillText(text.substring(0, 1), size / 2, size / 2 - 20);
            
            // Reset Shadow
            ctx.shadowBlur = 0;

            // Label
            ctx.font = '40px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.fillText(subtext, size / 2, size - 70);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createWindowContent(title, type) {
            const width = 1024;
            const height = 768;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Window Glass Effect
            ctx.fillStyle = 'rgba(10, 15, 30, 0.9)';
            ctx.beginPath();
            ctx.roundRect(0, 0, width, height, 40);
            ctx.fill();

            // Header
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(0, 0, width, 80);
            
            // Traffic Lights
            ctx.fillStyle = '#ff5f56'; ctx.beginPath(); ctx.arc(40, 40, 10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ffbd2e'; ctx.beginPath(); ctx.arc(80, 40, 10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#27c93f'; ctx.beginPath(); ctx.arc(120, 40, 10, 0, Math.PI*2); ctx.fill();

            // Title
            ctx.font = 'bold 36px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 52);

            // Dynamic Content
            ctx.textAlign = 'left';
            if (type === 'Browser') {
                // Search Bar
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.roundRect(50, 120, width-100, 60, 30);
                ctx.fill();
                ctx.fillStyle = '#aaa';
                ctx.font = '30px sans-serif';
                ctx.fillText("Search the spatial web...", 80, 160);
                
                // Boxes
                ctx.fillStyle = '#4a90e2'; ctx.fillRect(50, 220, 280, 200);
                ctx.fillStyle = '#50e3c2'; ctx.fillRect(370, 220, 280, 200);
                ctx.fillStyle = '#b8e986'; ctx.fillRect(690, 220, 280, 200);
            } 
            else if (type === 'Photos') {
                // Photo Grid
                const colors = ['#ff9a9e', '#fad0c4', '#a18cd1', '#fbc2eb', '#8fd3f4', '#84fab0'];
                let idx = 0;
                for(let y=0; y<2; y++) {
                    for(let x=0; x<3; x++) {
                        ctx.fillStyle = colors[idx % colors.length];
                        ctx.fillRect(50 + x*310, 120 + y*280, 290, 250);
                        idx++;
                    }
                }
            }
            else if (type === 'Settings') {
                 // Toggles
                 for(let i=0; i<4; i++) {
                     ctx.fillStyle = 'rgba(255,255,255,0.05)';
                     ctx.roundRect(50, 120 + i*140, width-100, 100, 20);
                     ctx.fill();
                     
                     ctx.fillStyle = 'white';
                     ctx.font = '36px sans-serif';
                     ctx.fillText(["Wi-Fi", "Bluetooth", "Immersion", "Notifications"][i], 80, 185 + i*140);
                     
                     // Toggle switch
                     ctx.fillStyle = i % 2 === 0 ? '#4cd964' : '#555';
                     ctx.roundRect(width-180, 145 + i*140, 100, 50, 25);
                     ctx.fill();
                     ctx.fillStyle = 'white';
                     ctx.beginPath();
                     ctx.arc(width - (i%2===0 ? 105 : 155), 170 + i*140, 20, 0, Math.PI*2);
                     ctx.fill();
                 }
            }
            else {
                ctx.font = '30px sans-serif';
                ctx.fillStyle = '#aaa';
                ctx.fillText("Application ready.", 50, 150);
                ctx.fillText("Tap screen to interact.", 50, 200);
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        function createStatusBarTexture() {
            const w = 1024;
            const h = 128;
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            ctx.font = 'bold 60px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            
            // Time
            const date = new Date();
            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            ctx.fillText(timeStr, w/2, h/2 + 20);
            
            // Battery icon (fake)
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.strokeRect(w - 120, h/2 - 20, 60, 40);
            ctx.fillRect(w - 116, h/2 - 16, 40, 32);
            ctx.fillRect(w - 60, h/2 - 10, 6, 20);
            
            // Wifi
            ctx.beginPath();
            ctx.arc(100, h/2 + 10, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(100, h/2 + 10, 20, Math.PI, 0);
            ctx.stroke();
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // --- THREE.JS SETUP ---

        function init3D() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 0.1);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; 
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xa0c4ff, 0.5);
            dirLight.position.set(0, 10, 0);
            scene.add(dirLight);

            // Build UI
            buildEnvironment();
            buildStatusBar();
            buildDock();
            buildReticles();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('touchstart', onTouchStart, false); 
            document.addEventListener('click', onTouchStart, false);
        }
        
        function buildEnvironment() {
            scene.add(envGroup);
            
            // Floor Grid
            const gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222);
            gridHelper.position.y = -4;
            envGroup.add(gridHelper);
            
            // Ceiling Grid (subtle)
            const ceilGrid = new THREE.GridHelper(40, 10, 0x222222, 0x111111);
            ceilGrid.position.y = 10;
            envGroup.add(ceilGrid);
        }
        
        function buildStatusBar() {
            const geometry = new THREE.PlaneGeometry(8, 1);
            const texture = createStatusBarTexture();
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            const bar = new THREE.Mesh(geometry, material);
            
            // Bend it slightly using position? 
            // We'll keep it flat but place it high
            bar.position.set(0, 3, -6);
            bar.lookAt(0, 0, 0); // Face center
            
            statusBarGroup.add(bar);
            scene.add(statusBarGroup);
            
            // Update time every minute? 
            // (Texture update logic omitted for single-file brevity, static for now)
        }

        function buildDock() {
            scene.add(appsGroup);

            const appList = [
                { name: "S", label: "Settings", color: "#A0C4FF" },
                { name: "B", label: "Browser", color: "#BDB2FF" },
                { name: "P", label: "Photos", color: "#FFC6FF" },
                { name: "M", label: "Mail", color: "#FFFFFC" },
                { name: "F", label: "Files", color: "#CAFFBF" }
            ];

            const radius = CONFIG.dockRadius;
            const totalArc = Math.PI / 2.5; 
            const angleStep = totalArc / (appList.length - 1);
            const startAngle = -totalArc / 2;

            appList.forEach((app, i) => {
                const geometry = new THREE.PlaneGeometry(CONFIG.iconSize, CONFIG.iconSize);
                const texture = createTextTexture(app.name, app.label, app.color);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0.95,
                    side: THREE.DoubleSide
                });

                const icon = new THREE.Mesh(geometry, material);
                
                const angle = startAngle + (i * angleStep);
                icon.position.x = radius * Math.sin(angle);
                icon.position.z = -radius * Math.cos(angle);
                icon.position.y = CONFIG.dockY;
                
                icon.lookAt(0, CONFIG.dockY, 0);

                icon.userData = { 
                    isIcon: true, 
                    label: app.label,
                    basePos: icon.position.clone()
                };

                appsGroup.add(icon);
                icons.push(icon);
            });
            
            scene.add(windowsGroup);
        }

        function buildReticles() {
            // Dual ring design
            const geometry = new THREE.RingGeometry(0.02, 0.025, 32);
            const geometryOuter = new THREE.RingGeometry(0.035, 0.038, 32);
            
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.reticleColor,
                transparent: true,
                opacity: 0.8,
                depthTest: false 
            });
            
            const materialOuter = new THREE.MeshBasicMaterial({ 
                color: CONFIG.hoverColor,
                transparent: true,
                opacity: 0.4,
                depthTest: false 
            });

            // Container for reticles
            reticleLeft = new THREE.Group();
            const l1 = new THREE.Mesh(geometry, material.clone());
            const l2 = new THREE.Mesh(geometryOuter, materialOuter.clone());
            reticleLeft.add(l1); reticleLeft.add(l2);
            
            reticleRight = new THREE.Group();
            const r1 = new THREE.Mesh(geometry, material.clone());
            const r2 = new THREE.Mesh(geometryOuter, materialOuter.clone());
            reticleRight.add(r1); reticleRight.add(r2);
            
            camera.add(reticleLeft);
            reticleLeft.position.set(0, 0, -2);
            
            scene.add(camera);
        }

        // --- INTERACTION LOGIC ---

        function openWindow(title) {
            while(windowsGroup.children.length > 0){ 
                windowsGroup.remove(windowsGroup.children[0]); 
            }

            const geometry = new THREE.PlaneGeometry(4.5, 3.2);
            const texture = createWindowContent(title, title);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide 
            });
            
            const win = new THREE.Mesh(geometry, material);
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            
            // Position 3.5 units away
            win.position.copy(camera.position).add(forward.multiplyScalar(3.5));
            // Slight look up
            win.position.y += 0.5;
            
            win.lookAt(camera.position);
            
            // Store base Y for animation
            win.userData = { baseY: win.position.y, floatOffset: Math.random() * 10 };
            
            windowsGroup.add(win);
        }

        function onTouchStart() {
            if (!isRunning) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(icons);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                if (hit.userData.isIcon) {
                    // Click Animation
                    hit.scale.set(0.9, 0.9, 0.9);
                    setTimeout(() => hit.scale.set(1, 1, 1), 100);
                    openWindow(hit.userData.label);
                }
            } else {
                // Close windows
                while(windowsGroup.children.length > 0){ 
                    windowsGroup.remove(windowsGroup.children[0]); 
                }
            }
        }

        // --- CORE LOOP ---

        function updateOrientation() {
            if (!deviceOrientation) return;

            const alpha = deviceOrientation.alpha ? THREE.Math.degToRad(deviceOrientation.alpha) : 0; 
            const beta = deviceOrientation.beta ? THREE.Math.degToRad(deviceOrientation.beta) : 0; 
            const gamma = deviceOrientation.gamma ? THREE.Math.degToRad(deviceOrientation.gamma) : 0; 
            const orient = screenOrientation ? THREE.Math.degToRad(screenOrientation) : 0;

            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const q = new THREE.Quaternion();
            q.setFromEuler(euler);
            
            const q_rot = new THREE.Quaternion();
            q_rot.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -orient);
            
            const q_fix = new THREE.Quaternion();
            q_fix.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), -Math.PI / 2 );

            camera.quaternion.copy(q);
            camera.quaternion.multiply(q_fix); 
            camera.quaternion.multiply(q_rot); 
        }

        function render() {
            requestAnimationFrame(render);
            const time = clock.getElapsedTime();

            updateOrientation();

            // Raycast logic
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(icons);
            
            // 1. Animate Dock Icons
            icons.forEach((icon, i) => {
                let targetScale = 1;
                let targetY = icon.userData.basePos.y + Math.sin(time * 2 + i) * 0.05; // Gentle float
                
                // Reset rotation
                icon.rotation.set(0, 0, 0); 
                icon.lookAt(0, CONFIG.dockY, 0); // Keep looking at center
                
                if (intersects.length > 0 && intersects[0].object === icon) {
                    targetScale = 1.3;
                    targetY += 0.2; // Lift up
                    
                    // Add subtle rotation on hover
                    icon.rotateZ(Math.sin(time * 5) * 0.05);
                }
                
                icon.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                icon.position.y += (targetY - icon.position.y) * 0.1;
            });

            // 2. Animate Windows
            windowsGroup.children.forEach(win => {
                if(win.userData.baseY) {
                    win.position.y = win.userData.baseY + Math.sin(time + win.userData.floatOffset) * 0.05;
                }
            });

            // 3. Stereo Render
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setScissorTest(true);

            // Left Eye
            renderer.setScissor(0, 0, width / 2, height);
            renderer.setViewport(0, 0, width / 2, height);
            camera.position.x = -CONFIG.ipd / 2;
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            // Right Eye
            renderer.setScissor(width / 2, 0, width / 2, height);
            renderer.setViewport(width / 2, 0, width / 2, height);
            camera.position.x = CONFIG.ipd / 2;
            camera.updateMatrixWorld();
            renderer.render(scene, camera);
            
            // Reset
            camera.position.x = 0;
            renderer.setScissorTest(false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- BOOT SEQUENCE ---

        const btn = document.getElementById('start-btn');
        const status = document.getElementById('status-text');
        const ui = document.getElementById('ui-layer');
        const video = document.getElementById('camera-feed');
        const divider = document.getElementById('vr-divider');

        btn.addEventListener('click', async () => {
            status.innerText = "Initializing Sensors & Camera...";

            // 1. Request Camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = stream;
            } catch (e) {
                console.warn("Camera failed: " + e);
                status.innerText = "Camera Access Denied (AR Disabled)";
            }

            // 2. Request Device Orientation
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        startSystem();
                    } else {
                        status.innerText = "Gyroscope Denied.";
                        return;
                    }
                } catch (e) {
                    status.innerText = "Sensor Error: " + e;
                    return;
                }
            } else {
                startSystem();
            }
        });

        function startSystem() {
            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 500);
            divider.style.display = 'block';

            window.addEventListener('deviceorientation', (e) => {
                deviceOrientation = e;
            });
            window.addEventListener('orientationchange', () => {
                screenOrientation = window.orientation || 0;
            });

            init3D();
            isRunning = true;
            render();

            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        }
    </script>
</body>
</html>
