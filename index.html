<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Connection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            cursor: crosshair;
            transition: background-color 2s;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            mix-blend-mode: difference;
            color: white;
            z-index: 10;
        }

        h1 {
            font-size: 8vw;
            margin: 0;
            letter-spacing: -5px;
            opacity: 0;
            animation: fadeIn 2s forwards;
        }

        p {
            font-size: 1.5rem;
            opacity: 0;
            animation: fadeIn 2s 1s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        #hud {
            position: absolute;
            top: 20px;
            right: 40px;
            text-align: right;
            pointer-events: none;
        }

        #score-display {
            font-size: 32px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        #highscore-display {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #lives-display {
            font-size: 20px;
            color: #ef4444;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 0 0 5px #ef4444;
        }

        #combo-display {
            font-size: 16px;
            color: #fbbf24;
            opacity: 0;
            transition: opacity 0.2s;
            margin-top: 5px;
        }

        /* Energy Bar Container */
        #energy-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            pointer-events: none;
        }

        #energy-bar {
            width: 100%;
            height: 100%;
            background: #38bdf8;
            border-radius: 3px;
            box-shadow: 0 0 10px #38bdf8;
            transition: width 0.1s linear, background-color 0.5s;
        }
        
        #status-display {
            position: absolute;
            top: 130px; /* Moved down to accommodate lives */
            right: 40px;
            font-size: 14px;
            color: #a78bfa;
            opacity: 0;
            transition: opacity 0.5s;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(167, 139, 250, 0.5);
        }
        
        #ascension-display {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            font-weight: bold;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            letter-spacing: 10px;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
            transform: scale(0.8);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        #ascension-sub {
            display: block;
            font-size: 16px;
            letter-spacing: 4px;
            margin-top: 10px;
            color: #fbbf24;
        }

        #boss-hp-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #ef4444;
            border-radius: 4px;
            display: none; /* Hidden by default */
            pointer-events: none;
        }

        #boss-hp-bar {
            width: 100%;
            height: 100%;
            background: #ef4444;
            transition: width 0.1s;
        }
        
        #boss-name {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            color: #ef4444;
            font-size: 12px;
            letter-spacing: 4px;
            display: none;
            text-shadow: 0 0 10px #ef4444;
        }

        #hint {
            position: absolute;
            bottom: 60px;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    <div id="ui">
        <h1 id="title">CONNECTION</h1>
        <p id="subtitle">Use Right-Click to Leash.</p>
    </div>
    <div id="hud">
        <div id="score-display">0</div>
        <div id="highscore-display">BEST: 0</div>
        <div id="lives-display">LIVES: 3</div>
        <div id="combo-display">x1 COMBO</div>
    </div>
    <div id="status-display">TIME DILATION</div>
    
    <div id="ascension-display">ASCENSION<span id="ascension-sub">ECHO STRIKE UNLOCKED</span></div>
    
    <div id="boss-hp-container"><div id="boss-hp-bar"></div></div>
    <div id="boss-name">VOID GUARDIAN</div>

    <div id="energy-container">
        <div id="energy-bar"></div>
    </div>
    
    <div id="hint">Green X2 splits the ball. Smash Boss with High Speed. 1000 PTS = Extra Life.</div>
</div>

<script>
/**
 * CONNECTION 
 * - Multiball System (Balls Array)
 * - Boss Battles (Void Guardian)
 * - New Procedural Audio for Boss/Split
 * - Lives System (3 Lives, Extra life every 1000 pts)
 * - Faster Energy Regen
 * - High Voltage Scoring
 */

// --- Audio System ---
const AudioEngine = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    scale: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25], 
    noteIndex: 0,
    leashOsc: null,
    leashGain: null,

    init() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },

    playImpact(velocity) {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        const note = this.scale[this.noteIndex % this.scale.length];
        const octave = velocity > 15 ? 2 : 1;
        
        osc.frequency.value = note * octave;
        osc.type = 'sine';

        filter.type = 'lowpass';
        filter.frequency.value = 200 + (velocity * 100);

        const t = this.ctx.currentTime;
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(Math.min(0.5, velocity * 0.05), t + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start(t);
        osc.stop(t + 0.3);

        this.noteIndex++;
    },

    playTarget(type, combo) {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const t = this.ctx.currentTime;
        const pitchMod = 1 + (combo * 0.1);

        if (type === 'MAGNET') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, t);
            osc.frequency.linearRampToValueAtTime(800, t + 0.5);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        } else if (type === 'NOVA') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(1500, t + 0.5);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.5);
        } else if (type === 'SLOW') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150 * pitchMod, t);
            osc.frequency.linearRampToValueAtTime(50, t + 1.0);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 1.0);
        } else if (type === 'ECHO') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.1);
        } else if (type === 'SPLIT') {
            const osc2 = this.ctx.createOscillator();
            osc.type = 'sine';
            osc2.type = 'sine';
            osc.frequency.setValueAtTime(440, t);
            osc2.frequency.setValueAtTime(440, t);
            osc.frequency.linearRampToValueAtTime(880, t+0.3);
            osc2.frequency.linearRampToValueAtTime(220, t+0.3);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t+0.3);
            osc.connect(gain);
            osc2.connect(gain);
            osc2.start(t);
            osc2.stop(t+0.3);
        } else if (type === 'LIFE') {
            // 1-Up Sound
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, t);
            osc.frequency.setValueAtTime(554, t + 0.1);
            osc.frequency.setValueAtTime(659, t + 0.2);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.4);
        } else {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(440 * pitchMod, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        }
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(t + 1.0);
    },

    playBossSpawn() {
        this.init();
        const t = this.ctx.currentTime;
        // FM Synthesis for growl
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const masterGain = this.ctx.createGain();

        carrier.type = 'sawtooth';
        modulator.type = 'sine';
        
        carrier.frequency.setValueAtTime(50, t);
        carrier.frequency.linearRampToValueAtTime(100, t+2);
        
        modulator.frequency.value = 30;
        modGain.gain.value = 500;

        modulator.connect(modGain);
        modGain.connect(carrier.frequency);
        carrier.connect(masterGain);
        masterGain.connect(this.ctx.destination);
        
        masterGain.gain.setValueAtTime(0, t);
        masterGain.gain.linearRampToValueAtTime(0.5, t+1);
        masterGain.gain.linearRampToValueAtTime(0, t+3);
        
        carrier.start(t);
        modulator.start(t);
        carrier.stop(t+3);
        modulator.stop(t+3);
    },

    playBossHit() {
        this.init();
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t+0.2);
        
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t+0.2);
    },

    playBossDeath() {
        this.init();
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.linearRampToValueAtTime(10, t+2);
        
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.linearRampToValueAtTime(0, t+2);
        
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        lfo.frequency.value = 15;
        lfoGain.gain.value = 1000;
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        lfo.start(t);
        osc.stop(t+2);
        lfo.stop(t+2);
    },

    playShatter() {
        this.init();
        const t = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(0.5, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        noise.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);
        noise.start();
    },
    
    playAscension() {
        this.init();
        const t = this.ctx.currentTime;
        [261.63, 329.63, 392.00, 523.25].forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.1, t + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(t + 2.0);
        });
    },
    
    startLeashSound() {
        if (this.leashOsc) return;
        this.init();
        this.leashOsc = this.ctx.createOscillator();
        this.leashGain = this.ctx.createGain();
        this.leashOsc.type = 'sawtooth';
        this.leashOsc.frequency.value = 100;
        this.leashGain.gain.value = 0;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;

        this.leashOsc.connect(filter);
        filter.connect(this.leashGain);
        this.leashGain.connect(this.ctx.destination);
        this.leashOsc.start();
        this.leashGain.gain.setTargetAtTime(0.15, this.ctx.currentTime, 0.1);
    },
    
    stopLeashSound() {
        if (!this.leashOsc) return;
        this.leashGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
        const oldOsc = this.leashOsc;
        const oldGain = this.leashGain;
        this.leashOsc = null;
        this.leashGain = null;
        setTimeout(() => { oldOsc.stop(); oldOsc.disconnect(); oldGain.disconnect(); }, 200);
    },

    playFail() {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 1);
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
    },
    
    playShieldBreak() {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    },
    
    playShieldRegen() {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.4);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
    },

    playComboReset() {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }
};

// --- Physics & Game Loop ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;

// Config
const GRAVITY = 0.25;
const FRICTION = 0.99;
const LINE_DECAY = 0.05;
const TARGET_TYPES = ['NORMAL', 'NORMAL', 'NORMAL', 'SLOW', 'GRAVITY', 'HAZARD', 'HAZARD', 'NOVA', 'MAGNET', 'SPLIT'];
const SMASH_SPEED_THRESHOLD = 18;

// Palettes
const PALETTES = [
    { bg: '#050505', ball: '#fff', hazard: '#ef4444', friendly: '#38bdf8', grid: '#1a1a1a' }, 
    { bg: '#1a1005', ball: '#fbbf24', hazard: '#991b1b', friendly: '#f59e0b', grid: '#451a03' }, 
    { bg: '#10051a', ball: '#d8b4fe', hazard: '#be185d', friendly: '#a855f7', grid: '#4c1d95' }, 
    { bg: '#020617', ball: '#94a3b8', hazard: '#b91c1c', friendly: '#e2e8f0', grid: '#0f172a' } 
];
let currentPalette = PALETTES[0];

// State
let gameActive = false;
let score = 0;
let highScore = parseInt(localStorage.getItem('lifeline_highscore')) || 0;
let combo = 1;
let frames = 0;
let shake = 0;
let timeScale = 1.0;
let timeSlowTimer = 0;
let magnetTimer = 0;

// Boss State
let boss = { active: false, hp: 100, maxHp: 100, x: 0, y: 0, r: 40 };

// Ascension State
let ascensionLevel = 0;
let nextAscensionScore = 500;
let echoes = []; 

// Player Abilities
let energy = 100;
let shield = 1;
let lives = 3;
let nextLifeScore = 1000;
let leashActive = false;

// Grid
let gridPoints = [];
const GRID_SPACING = 50;

// Entities
let balls = []; 
let targets = [];
let chasers = [];
let particles = [];
let floatingTexts = [];
let activeLine = null;
let mouse = { x: 0, y: 0, px: 0, py: 0, down: false, rightDown: false };

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initGrid();
}
window.addEventListener('resize', resize);

function initGrid() {
    gridPoints = [];
    for(let x=0; x<=width; x+=GRID_SPACING) {
        for(let y=0; y<=height; y+=GRID_SPACING) {
            gridPoints.push({
                x: x, y: y,
                baseX: x, baseY: y,
                vx: 0, vy: 0
            });
        }
    }
}
resize();

function spawnBall() {
    balls.push({ x: width / 2, y: height / 4, vx: 0, vy: 0, r: 8, trail: [] });
    createExplosion(width/2, height/4, '#fff', 20);
    spawnFloatingText(width/2, height/4, "RESPAWN", "#fff");
}

function resetGame() {
    balls = [];
    spawnBall();
    targets = [];
    chasers = [];
    particles = [];
    floatingTexts = [];
    echoes = [];
    score = 0;
    combo = 1;
    activeLine = null;
    shake = 0;
    timeScale = 1.0;
    magnetTimer = 0;
    
    boss.active = false;
    document.getElementById('boss-hp-container').style.display = 'none';
    document.getElementById('boss-name').style.display = 'none';

    // Reset Ascension
    ascensionLevel = 0;
    nextAscensionScore = 500;
    currentPalette = PALETTES[0];
    document.body.style.backgroundColor = currentPalette.bg;

    // Reset Stats
    energy = 100;
    shield = 1;
    lives = 3;
    nextLifeScore = 1000;
    leashActive = false;
    
    // Spawn multiple initial targets for more points potential
    spawnTarget(true); 
    spawnTarget(true); 
    spawnTarget(); 
    
    gameActive = true;
    
    document.getElementById('ui').style.opacity = 0;
    document.getElementById('ascension-display').style.opacity = 0;
    updateHUD();
    document.getElementById('status-display').style.opacity = 0;
}

function triggerAscension(level) {
    ascensionLevel = level;
    shake = 20;
    AudioEngine.playAscension();
    
    let text = "";
    if (level === 1) {
        text = "ECHO STRIKE ACTIVE";
        currentPalette = PALETTES[1];
        nextAscensionScore = 1500;
    } else if (level === 2) {
        text = "INFINITE ENERGY";
        currentPalette = PALETTES[2];
        nextAscensionScore = 3000;
    } else if (level === 3) {
        text = "REACTIVE ARMOR";
        currentPalette = PALETTES[3];
        nextAscensionScore = 999999;
    }
    
    document.body.style.backgroundColor = currentPalette.bg;
    
    const el = document.getElementById('ascension-display');
    const sub = document.getElementById('ascension-sub');
    el.innerHTML = `ASCENSION ${level}<span id="ascension-sub">${text}</span>`;
    el.style.opacity = 1;
    el.style.transform = "scale(1.2)";
    setTimeout(() => {
        el.style.opacity = 0;
        el.style.transform = "scale(0.8)";
    }, 3000);
}

function spawnBoss() {
    boss.active = true;
    boss.x = width/2;
    boss.y = height/3;
    boss.maxHp = 200 * (ascensionLevel + 1);
    boss.hp = boss.maxHp;
    boss.r = 40;
    
    targets = [];
    chasers = [];
    
    AudioEngine.playBossSpawn();
    shake = 30;
    
    document.getElementById('boss-hp-container').style.display = 'block';
    document.getElementById('boss-name').style.display = 'block';
    spawnFloatingText(width/2, height/2, "VOID GUARDIAN", "#ef4444");
}

function spawnEcho(startX, startY) {
    let bestDist = 9999;
    let target = null;
    targets.forEach(t => {
        if (t.type !== 'HAZARD') {
            const d = dist(startX, startY, t.x, t.y);
            if (d < bestDist) {
                bestDist = d;
                target = t;
            }
        }
    });
    
    if (target) {
        echoes.push({
            x: startX, y: startY,
            target: target,
            speed: 15,
            life: 60
        });
    }
}

function spawnTarget(safe = false) {
    if (boss.active) return; 

    let type = TARGET_TYPES[Math.floor(Math.random() * TARGET_TYPES.length)];
    if (safe) type = 'NORMAL';

    const pad = 100;
    let tx, ty, d;
    
    const b = balls[0] || {x:width/2, y:height/2};
    
    do {
        tx = Math.random() * (width - pad*2) + pad;
        ty = Math.random() * (height - pad*2) + pad;
        d = dist(b.x, b.y, tx, ty);
    } while(d < 200);

    targets.push({
        x: tx,
        y: ty,
        r: 15 + Math.random() * 10,
        pulse: 0,
        type: type,
        vx: (Math.random() - 0.5) * 0.5, 
        vy: (Math.random() - 0.5) * 0.5
    });
}

function spawnChaser() {
    if (boss.active) return;
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if(side === 0) { x = Math.random()*width; y = -50; }
    else if(side === 1) { x = width+50; y = Math.random()*height; }
    else if(side === 2) { x = Math.random()*width; y = height+50; }
    else { x = -50; y = Math.random()*height; }

    chasers.push({
        x: x, y: y,
        r: 6,
        speed: 1.5 + Math.random() * 1.5
    });
}

function spawnFloatingText(x, y, text, color) {
    floatingTexts.push({
        x: x, y: y,
        text: text,
        color: color,
        life: 1.0,
        vy: -1
    });
}

function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            color: color,
            decay: 0.02 + Math.random() * 0.03
        });
    }
}

function updateHUD() {
    document.getElementById('score-display').innerText = score;
    document.getElementById('highscore-display').innerText = `BEST: ${highScore}`;
    document.getElementById('lives-display').innerText = `LIVES: ${lives}`;
    const c = document.getElementById('combo-display');
    c.innerText = `x${combo} COMBO`;
    c.style.opacity = combo > 1 ? 1 : 0.3;
    c.style.color = combo > 5 ? currentPalette.friendly : '#fff';
    
    const eb = document.getElementById('energy-bar');
    eb.style.width = `${energy}%`;
    eb.style.backgroundColor = energy < 20 ? currentPalette.hazard : currentPalette.friendly;

    if (boss.active) {
        const bhp = document.getElementById('boss-hp-bar');
        bhp.style.width = `${(boss.hp / boss.maxHp) * 100}%`;
    }
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

function lineCircleCollision(x1, y1, x2, y2, cx, cy, r) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lenSq = dx*dx + dy*dy;
    let t = ((cx - x1) * dx + (cy - y1) * dy) / lenSq;
    t = Math.max(0, Math.min(1, t));
    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;
    const distance = dist(cx, cy, closestX, closestY);
    
    if (distance <= r) {
        return {
            collision: true,
            nx: (cx - closestX) / distance,
            ny: (cy - closestY) / distance
        };
    }
    return { collision: false };
}

function damagePlayer(ballIndex) {
    if (shield > 0) {
        shield--;
        AudioEngine.playShieldBreak();
        shake = 20;
        const b = balls[ballIndex];
        spawnFloatingText(b.x, b.y, "SHIELD BROKEN", currentPalette.hazard);
        createExplosion(b.x, b.y, currentPalette.friendly, 30);
        b.vy = -15; 
        b.vx = (Math.random() - 0.5) * 10;
    } else {
        // Remove ball
        createExplosion(balls[ballIndex].x, balls[ballIndex].y, '#fff', 20);
        balls.splice(ballIndex, 1);
        AudioEngine.playFail();
        
        if (balls.length === 0) {
            if (lives > 0) {
                lives--;
                spawnBall();
                updateHUD();
            } else {
                gameOver();
            }
        }
    }
}

function update() {
    if (!gameActive) {
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy;
            p.life -= p.decay;
            if(p.life <= 0) particles.splice(i, 1);
        });
        return;
    }

    // Score based life gain
    if (score >= nextLifeScore) {
        lives++;
        nextLifeScore += 1000;
        spawnFloatingText(width/2, height/2 - 50, "EXTRA LIFE", "#4ade80");
        AudioEngine.playTarget('LIFE', 1);
        updateHUD();
    }

    // Ascension Check
    if (score >= nextAscensionScore && !boss.active) {
        triggerAscension(ascensionLevel + 1);
    }
    
    if (!boss.active && ((score > 1000 && score < 1100 && ascensionLevel < 2) || (score > 3000 && score < 3100 && ascensionLevel < 3))) {
        spawnBoss();
    }

    // Time & Status Management
    if (timeSlowTimer > 0) {
        timeSlowTimer--;
        timeScale = 0.2; 
        document.getElementById('status-display').innerText = "TIME DILATION";
        document.getElementById('status-display').style.opacity = 1;
        document.getElementById('status-display').style.color = '#fbbf24';
    } else if (magnetTimer > 0) {
        magnetTimer--;
        document.getElementById('status-display').innerText = "MAGNET ACTIVE";
        document.getElementById('status-display').style.opacity = 1;
        document.getElementById('status-display').style.color = currentPalette.friendly;
    } else {
        timeScale += (1.0 - timeScale) * 0.05; 
        if (timeScale > 0.95) {
            timeScale = 1.0;
            document.getElementById('status-display').style.opacity = 0;
        }
    }

    // --- LEASH MECHANIC ---
    const hasInfiniteEnergy = ascensionLevel >= 2;
    
    if (mouse.rightDown && (energy > 0 || hasInfiniteEnergy)) {
        leashActive = true;
        if (!hasInfiniteEnergy) energy -= 0.4;
        
        balls.forEach(b => {
            const angle = Math.atan2(mouse.y - b.y, mouse.x - b.x);
            const distToMouse = dist(b.x, b.y, mouse.x, mouse.y);
            const force = 1.5; 
            
            b.vx += Math.cos(angle) * force * timeScale;
            b.vy += Math.sin(angle) * force * timeScale;
            
            if (distToMouse < 100) {
                b.vx *= 0.9;
                b.vy *= 0.9;
            }
        });

        AudioEngine.startLeashSound();
    } else {
        leashActive = false;
        // Faster Regen: +0.5 per frame instead of 0.1
        if (energy < 100) energy += 0.5; 
        AudioEngine.stopLeashSound();
    }
    updateHUD(); 

    if (frames % 180 === 0 && targets.length < 5) spawnChaser();

    // Loop through balls (Reverse for splice safety)
    for (let i = balls.length - 1; i >= 0; i--) {
        let b = balls[i];
        
        // Physics
        b.vy += GRAVITY * timeScale;
        b.vx *= Math.pow(FRICTION, timeScale);
        b.vy *= Math.pow(FRICTION, timeScale);
        
        const steps = 5;
        for(let s=0; s<steps; s++) {
            b.x += (b.vx * timeScale) / steps;
            b.y += (b.vy * timeScale) / steps;

            if (activeLine && activeLine.points.length > 1) {
                for (let k = 0; k < activeLine.points.length - 1; k++) {
                    const p1 = activeLine.points[k];
                    const p2 = activeLine.points[k+1];
                    const col = lineCircleCollision(p1.x, p1.y, p2.x, p2.y, b.x, b.y, b.r);
                    
                    if (col.collision) {
                        const dot = b.vx * col.nx + b.vy * col.ny;
                        b.vx = b.vx - 2 * dot * col.nx;
                        b.vy = b.vy - 2 * dot * col.ny;
                        
                        const strikeForce = 0.5;
                        b.vx += activeLine.velocity.x * strikeForce;
                        b.vy += activeLine.velocity.y * strikeForce;

                        b.x += col.nx * (b.r + 1);
                        b.y += col.ny * (b.r + 1);

                        const impactSpeed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                        createExplosion(b.x, b.y, currentPalette.ball, Math.min(10, impactSpeed));
                        AudioEngine.playImpact(impactSpeed);
                        applyGridForce(b.x, b.y, 200, 15);

                        if (impactSpeed > 10) shake = 5;
                        if (impactSpeed > 20) shake = 10;
                        
                        const maxSpeed = 35;
                        const speed = Math.sqrt(b.vx**2 + b.vy**2);
                        if (speed > maxSpeed) {
                            b.vx = (b.vx / speed) * maxSpeed;
                            b.vy = (b.vy / speed) * maxSpeed;
                        }

                        activeLine.life -= 0.2;
                        break;
                    }
                }
            }
        }

        const currentSpeed = Math.sqrt(b.vx**2 + b.vy**2);

        if (b.x < b.r) { 
            b.x = b.r; b.vx *= -0.8; 
            if(combo > 1) { combo = 1; AudioEngine.playComboReset(); updateHUD(); }
        }
        if (b.x > width - b.r) { 
            b.x = width - b.r; b.vx *= -0.8; 
            if(combo > 1) { combo = 1; AudioEngine.playComboReset(); updateHUD(); }
        }
        if (b.y > height + 50 || b.y < -200) {
            damagePlayer(i);
            continue; 
        }
        
        if (boss.active) {
            boss.x += Math.sin(frames * 0.02) * 2;
            boss.y += Math.cos(frames * 0.03) * 1;

            if (dist(b.x, b.y, boss.x, boss.y) < b.r + boss.r) {
                const angle = Math.atan2(b.y - boss.y, b.x - boss.x);
                b.vx = Math.cos(angle) * 10;
                b.vy = Math.sin(angle) * 10;
                
                if (currentSpeed > SMASH_SPEED_THRESHOLD) {
                    boss.hp -= 10;
                    shake = 10;
                    AudioEngine.playBossHit();
                    spawnFloatingText(boss.x, boss.y, "-10", "#ef4444");
                    createExplosion(b.x, b.y, "#ef4444", 20);
                    
                    if (boss.hp <= 0) {
                        boss.active = false;
                        AudioEngine.playBossDeath();
                        createExplosion(boss.x, boss.y, "#fff", 100);
                        shake = 50;
                        score += 5000; // INCREASED BOSS SCORE
                        spawnFloatingText(boss.x, boss.y, "GUARDIAN DEFEATED (+5000)", "#fff");
                        document.getElementById('boss-hp-container').style.display = 'none';
                        document.getElementById('boss-name').style.display = 'none';
                        spawnTarget();
                    }
                } else {
                    createExplosion(b.x, b.y, "#555", 5);
                }
            }
        }

        for (let j = chasers.length - 1; j >= 0; j--) {
            const c = chasers[j];
            if (i === 0) {
                const angle = Math.atan2(b.y - c.y, b.x - c.x);
                c.x += Math.cos(angle) * c.speed * timeScale;
                c.y += Math.sin(angle) * c.speed * timeScale;
            }

            if (dist(b.x, b.y, c.x, c.y) < b.r + c.r) {
                if (currentSpeed > SMASH_SPEED_THRESHOLD) {
                    chasers.splice(j, 1);
                    createExplosion(c.x, c.y, currentPalette.hazard, 15);
                    AudioEngine.playShatter();
                    shake = 10;
                    score += 200 * combo; // INCREASED CHASER SCORE
                    spawnFloatingText(c.x, c.y, "SMASH! (+200)", currentPalette.hazard);
                    updateHUD();
                } else {
                    chasers.splice(j, 1); 
                    damagePlayer(i);
                    if (balls.length <= i) break; 
                }
            }
        }

        for (let j = targets.length - 1; j >= 0; j--) {
            const t = targets[j];
            if (dist(b.x, b.y, t.x, t.y) < b.r + t.r) {
                if (t.type === 'HAZARD') {
                    if (currentSpeed > SMASH_SPEED_THRESHOLD) {
                        targets.splice(j, 1);
                        createExplosion(t.x, t.y, currentPalette.hazard, 20);
                        AudioEngine.playShatter();
                        shake = 15;
                        score += 300 * combo; // INCREASED HAZARD SCORE
                        spawnFloatingText(t.x, t.y, "CRUSH! (+300)", currentPalette.hazard);
                        updateHUD();
                        continue;
                    } else {
                        targets.splice(j, 1); 
                        damagePlayer(i);
                         if (balls.length <= i) break;
                        continue;
                    }
                }

                score += 50 * combo; // INCREASED BASE SCORE
                combo++;
                
                if (ascensionLevel >= 1) spawnEcho(t.x, t.y);

                const regenThreshold = (ascensionLevel >= 3) ? 2 : 10;
                if (combo % regenThreshold === 0 && shield < 1) {
                    shield++;
                    AudioEngine.playShieldRegen();
                    spawnFloatingText(b.x, b.y, "SHIELD RESTORED", currentPalette.friendly);
                }
                
                if (t.type === 'SPLIT') {
                    AudioEngine.playTarget('SPLIT', combo);
                    spawnFloatingText(t.x, t.y, "MULTIBALL", "#4ade80");
                    balls.push({
                        x: b.x, y: b.y, vx: -b.vx, vy: -b.vy, r: 8, trail: []
                    });
                } else {
                    spawnFloatingText(t.x, t.y, `+${50*combo}`, "#fff");
                }
                
                updateHUD();
                
                let col = currentPalette.friendly;
                if (t.type === 'SLOW') col = '#fbbf24';
                if (t.type === 'GRAVITY') col = '#a78bfa';
                if (t.type === 'NOVA') col = '#fff';
                if (t.type === 'SPLIT') col = '#4ade80';

                createExplosion(t.x, t.y, col, 20);
                AudioEngine.playTarget(t.type, combo);
                applyGridForce(t.x, t.y, 100, 10);
                
                if (t.type === 'SLOW') { timeSlowTimer = 180; shake = 5; }
                if (t.type === 'GRAVITY') shake = 15;
                if (t.type === 'MAGNET') { magnetTimer = 300; shake = 5; }
                if (t.type === 'NOVA') {
                    targets = targets.filter(tg => tg.type !== 'HAZARD');
                    chasers = []; 
                    shake = 20;
                    createExplosion(width/2, height/2, '#fff', 50);
                    spawnFloatingText(width/2, height/2, "PURGED", "#fff");
                }
                
                if (energy < 100) energy = Math.min(100, energy + 10);

                targets.splice(j, 1);
                spawnTarget();
            }
        }
        
        if (frames % 2 === 0) {
            b.trail.push({x: b.x, y: b.y, life: 1.0});
        }
        b.trail.forEach((t, k) => {
            t.life -= 0.02 * timeScale;
            if (t.life <= 0) b.trail.splice(k, 1);
        });
    }

    updateGrid();
    if (activeLine) {
        activeLine.life -= LINE_DECAY;
        if (activeLine.life <= 0) activeLine = null;
    }
    
    for (let i = targets.length - 1; i >= 0; i--) {
        const t = targets[i];
        t.pulse += 0.05;
        if (magnetTimer > 0 && balls.length > 0) {
            const angle = Math.atan2(balls[0].y - t.y, balls[0].x - t.x);
            t.vx += Math.cos(angle) * 0.5;
            t.vy += Math.sin(angle) * 0.5;
            t.vx *= 0.9; t.vy *= 0.9;
        }
        t.x += t.vx * timeScale; t.y += t.vy * timeScale;
        if(t.x < 50 || t.x > width-50) t.vx *= -1;
        if(t.y < 50 || t.y > height-50) t.vy *= -1;
    }
    // Echo Logic
    for (let i = echoes.length - 1; i >= 0; i--) {
        const e = echoes[i];
        if (e.target && targets.includes(e.target)) {
            const angle = Math.atan2(e.target.y - e.y, e.target.x - e.x);
            e.x += Math.cos(angle) * e.speed;
            e.y += Math.sin(angle) * e.speed;
            e.life--;
            particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 0.5, color: currentPalette.ball, decay: 0.1 });

            if (dist(e.x, e.y, e.target.x, e.target.y) < 20) {
                const tIndex = targets.indexOf(e.target);
                if (tIndex !== -1) {
                    targets.splice(tIndex, 1);
                    score += 100 * combo; // INCREASED ECHO SCORE
                    createExplosion(e.target.x, e.target.y, currentPalette.ball, 10);
                    AudioEngine.playTarget('ECHO', combo);
                    spawnTarget();
                    updateHUD();
                }
                echoes.splice(i, 1);
            }
        } else {
            echoes.splice(i, 1);
        }
    }

    particles.forEach((p, i) => {
        p.x += p.vx * timeScale;
        p.y += p.vy * timeScale;
        p.life -= p.decay;
        if(p.life <= 0) particles.splice(i, 1);
    });

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.y += ft.vy;
        ft.life -= 0.02;
        if (ft.life <= 0) floatingTexts.splice(i, 1);
    }
    
    if (shake > 0) shake *= 0.9;
    if (shake < 0.5) shake = 0;

    frames++;
}

// --- Grid System ---
function applyGridForce(x, y, radius, strength) {
    gridPoints.forEach(p => {
        const d = dist(x, y, p.x, p.y);
        if (d < radius) {
            const angle = Math.atan2(p.y - y, p.x - x);
            const force = (1 - d/radius) * strength;
            p.vx += Math.cos(angle) * force;
            p.vy += Math.sin(angle) * force;
        }
    });
}

function updateGrid() {
    const b = balls[0];
    gridPoints.forEach(p => {
        if (b) {
            const d = dist(b.x, b.y, p.x, p.y);
            if (d < 150) {
                 const angle = Math.atan2(p.y - b.y, p.x - b.x);
                 p.vx += Math.cos(angle) * 0.5;
                 p.vy += Math.sin(angle) * 0.5;
            }
        }
        if (boss.active) {
            const d = dist(boss.x, boss.y, p.x, p.y);
             if (d < 200) {
                 const angle = Math.atan2(p.y - boss.y, p.x - boss.x);
                 p.vx += Math.cos(angle) * 0.5;
                 p.vy += Math.sin(angle) * 0.5;
            }
        }

        const dx = p.x - p.baseX;
        const dy = p.y - p.baseY;
        p.vx -= dx * 0.05;
        p.vy -= dy * 0.05;
        p.vx *= 0.9; 
        p.vy *= 0.9;
        p.x += p.vx * timeScale;
        p.y += p.vy * timeScale;
    });
}

function drawGrid() {
    ctx.fillStyle = currentPalette.grid;
    gridPoints.forEach(p => {
        ctx.fillRect(p.x, p.y, 2, 2);
    });
}

function gameOver() {
    gameActive = false;
    AudioEngine.stopLeashSound();
    
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('lifeline_highscore', highScore);
    }
    
    document.getElementById('ui').style.opacity = 1;
    document.getElementById('title').innerText = "SEVERED";
    document.getElementById('subtitle').innerText = `Final Score: ${score} // Click to Reset`;
}

// --- Rendering ---
function draw() {
    ctx.fillStyle = currentPalette.bg + "66"; 
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    
    if (shake > 0) {
        const dx = (Math.random() - 0.5) * shake;
        const dy = (Math.random() - 0.5) * shake;
        ctx.translate(dx, dy);
    }

    drawGrid();
    
    if (leashActive) {
        balls.forEach(b => {
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.strokeStyle = currentPalette.friendly;
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 10]);
            ctx.lineDashOffset = -frames * 2;
            ctx.stroke();
        });
        ctx.setLineDash([]);
    }

    if (boss.active) {
        const dx = (Math.random()-0.5)*5;
        const dy = (Math.random()-0.5)*5;
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        for(let i=0; i<16; i++) {
             const angle = (i/16)*Math.PI*2 + frames*0.02;
             const r = boss.r + (i%2===0 ? 10 : -5);
             const px = boss.x + dx + Math.cos(angle)*r;
             const py = boss.y + dy + Math.sin(angle)*r;
             if(i===0) ctx.moveTo(px, py);
             else ctx.lineTo(px, py);
        }
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(boss.x + dx, boss.y + dy, 15, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.fillStyle = currentPalette.hazard;
    chasers.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.fillRect(c.x-2, c.y-2, 4, 4);
        ctx.fillStyle = currentPalette.hazard;
    });

    ctx.fillStyle = currentPalette.ball;
    echoes.forEach(e => {
        ctx.beginPath();
        ctx.arc(e.x, e.y, 3, 0, Math.PI*2);
        ctx.fill();
    });

    targets.forEach(t => {
        const pulseSize = Math.sin(t.pulse) * 5;
        let color = currentPalette.friendly; 
        
        if (t.type === 'SLOW') color = '#fbbf24'; 
        if (t.type === 'GRAVITY') color = '#a78bfa'; 
        if (t.type === 'HAZARD') color = currentPalette.hazard;
        if (t.type === 'NOVA') color = '#fff';
        if (t.type === 'MAGNET') color = '#38bdf8';
        if (t.type === 'SPLIT') color = '#4ade80';

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        if (t.type === 'NORMAL') {
            ctx.arc(t.x, t.y, t.r + pulseSize, 0, Math.PI*2);
        } else if (t.type === 'HAZARD') {
            for(let i=0; i<8; i++) {
                const angle = (i/8) * Math.PI*2 + frames*0.05;
                const r = t.r + (i%2===0 ? 5 : -5);
                const px = t.x + Math.cos(angle) * r;
                const py = t.y + Math.sin(angle) * r;
                if(i===0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        } else if (t.type === 'NOVA') {
            ctx.arc(t.x, t.y, t.r + pulseSize + 2, 0, Math.PI*2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(t.x, t.y, t.r/2, 0, Math.PI*2);
        } else if (t.type === 'SPLIT') {
            const r = t.r + pulseSize;
            ctx.moveTo(t.x - r, t.y - r); ctx.lineTo(t.x + r, t.y + r);
            ctx.moveTo(t.x + r, t.y - r); ctx.lineTo(t.x - r, t.y + r);
        } else if (t.type === 'SLOW') {
            ctx.rect(t.x - t.r, t.y - t.r, t.r*2, t.r*2);
        } else if (t.type === 'GRAVITY') {
            ctx.moveTo(t.x, t.y - t.r); ctx.lineTo(t.x + t.r, t.y);
            ctx.lineTo(t.x, t.y + t.r); ctx.lineTo(t.x - t.r, t.y);
            ctx.closePath();
        } else if (t.type === 'MAGNET') {
            ctx.arc(t.x, t.y, t.r + pulseSize, 0, Math.PI, true); 
            ctx.lineTo(t.x + t.r + pulseSize, t.y - 5);
            ctx.moveTo(t.x - t.r - pulseSize, t.y);
            ctx.lineTo(t.x - t.r - pulseSize, t.y - 5);
        }
        
        ctx.stroke();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.1;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        ctx.fillStyle = color;
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (t.type === 'SLOW') ctx.fillText('TIME', t.x, t.y);
        if (t.type === 'GRAVITY') ctx.fillText('PULL', t.x, t.y);
        if (t.type === 'HAZARD') ctx.fillText('VOID', t.x, t.y);
        if (t.type === 'NOVA') ctx.fillText('NOVA', t.x, t.y);
        if (t.type === 'MAGNET') ctx.fillText('MAG', t.x, t.y);
        if (t.type === 'SPLIT') ctx.fillText('X2', t.x, t.y);
    });

    if (activeLine) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${activeLine.life})`;
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        if (activeLine.points.length > 0) {
            ctx.moveTo(activeLine.points[0].x, activeLine.points[0].y);
            for (let i = 1; i < activeLine.points.length; i++) {
                ctx.lineTo(activeLine.points[i].x, activeLine.points[i].y);
            }
        }
        ctx.stroke();
        
        if (activeLine.points.length > 0) {
            const head = activeLine.points[activeLine.points.length-1];
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#fff';
            ctx.beginPath();
            ctx.arc(head.x, head.y, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    balls.forEach(b => {
        if (b.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(b.trail[0].x, b.trail[0].y);
            for(let t of b.trail) ctx.lineTo(t.x, t.y);
            ctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    });

    if (gameActive) {
        balls.forEach(b => {
            const speed = Math.sqrt(b.vx**2 + b.vy**2);
            
            if (speed > SMASH_SPEED_THRESHOLD) {
                ctx.beginPath();
                ctx.moveTo(b.x - b.vx*2, b.y - b.vy*2);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = b.r;
                ctx.stroke();
            }

            ctx.fillStyle = currentPalette.ball;
            ctx.shadowBlur = 20;
            ctx.shadowColor = currentPalette.friendly;
            
            if (combo > 5) {
                ctx.shadowColor = '#f0f';
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = '#0ff';
                ctx.beginPath(); ctx.arc(b.x - 2, b.y, b.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#f00';
                ctx.beginPath(); ctx.arc(b.x + 2, b.y, b.r, 0, Math.PI*2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = '#fff';
            }
    
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        });
        
        if (shield > 0 && balls.length > 0) {
            balls.forEach(b => {
                ctx.strokeStyle = `rgba(56, 189, 248, ${0.5 + Math.sin(frames*0.1)*0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r + 5, 0, Math.PI*2);
                ctx.stroke();
            });
        }
    }

    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    floatingTexts.forEach(ft => {
        ctx.fillStyle = ft.color;
        ctx.globalAlpha = ft.life;
        ctx.font = 'bold 20px Courier New';
        ctx.fillText(ft.text, ft.x, ft.y);
    });
    ctx.globalAlpha = 1;

    ctx.restore();
    requestAnimationFrame(draw);
}

// --- Input Handling ---
function getPos(e) {
    if (e.touches && e.touches.length > 0) {
        return {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
    }
    return {
        x: e.clientX,
        y: e.clientY
    };
}

function startLine(e) {
    if (!gameActive) {
        resetGame();
        return;
    }
    
    if (e.button === 2) {
        mouse.rightDown = true;
        const pos = getPos(e);
        mouse.x = pos.x;
        mouse.y = pos.y;
        return;
    }

    const pos = getPos(e);
    mouse.down = true;
    mouse.x = pos.x;
    mouse.y = pos.y;
    mouse.px = pos.x;
    mouse.py = pos.y;
    
    activeLine = {
        points: [{x: pos.x, y: pos.y}],
        life: 1.0,
        velocity: {x: 0, y: 0}
    };
}

function moveLine(e) {
    const pos = getPos(e);
    mouse.x = pos.x;
    mouse.y = pos.y;
    
    if (mouse.down && activeLine) {
       const lastPt = activeLine.points[activeLine.points.length-1];
       const vx = mouse.x - lastPt.x;
       const vy = mouse.y - lastPt.y;
       activeLine.velocity = { x: vx, y: vy };
       
       activeLine.points.push({x: mouse.x, y: mouse.y});
       if (activeLine.points.length > 20) activeLine.points.shift();
       activeLine.life = 1.0;
    }
}

function endLine(e) {
    if (e.button === 2) {
        mouse.rightDown = false;
        return;
    }
    mouse.down = false;
}

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') mouse.rightDown = true;
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') mouse.rightDown = false;
});

window.addEventListener('contextmenu', e => e.preventDefault());

window.addEventListener('mousedown', startLine);
window.addEventListener('mousemove', moveLine);
window.addEventListener('mouseup', endLine);

window.addEventListener('touchstart', (e) => { e.preventDefault(); startLine(e); }, {passive: false});
window.addEventListener('touchmove', (e) => { e.preventDefault(); moveLine(e); }, {passive: false});
window.addEventListener('touchend', endLine);

setInterval(update, 1000/60);
draw();

</script>
</body>
</html>
